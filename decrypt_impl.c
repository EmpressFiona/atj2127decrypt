#include <string.h>
#include <stdint.h>
#include <assert.h>
#include <stdio.h>

#include "decrypt_impl.h"

unsigned char firmware_directory_key[] = { // aka _key_2950 aka data_3000
	0x16, 0x2b, 0x01, 0xe4, 0x0e, 0x3d, 0xc1, 0xdf, 0x0f, 0x35, 0x8f, 0xf5, 0xe2, 0x48, 0xa0, 0x2e,
	0x1c, 0x6a, 0x57, 0xea, 0x6d, 0x9a, 0xe2, 0x03, 0xec, 0xe8, 0x84, 0x9c, 0x87, 0xca, 0xba, 0xcf,
	0xdb, 0x5c, 0x6f, 0xf2, 0x32, 0x72, 0xe9, 0x50, 0x42, 0x06, 0x1b, 0xe9, 0x9d, 0x8f, 0xa4, 0xff,
	0x66, 0x64, 0x59, 0xb7, 0xd0, 0x15, 0x3c, 0x42, 0x27, 0x25, 0x52, 0x47, 0x83, 0x09, 0x7c, 0x55,
	0x1d, 0xc1, 0x12, 0xfa, 0x7c, 0xaa, 0xf8, 0x60, 0xc6, 0x65, 0x3a, 0xf3, 0x13, 0x44, 0xa7, 0x5e,
	0xc7, 0x22, 0x7e, 0x91, 0xdf, 0x98, 0xf2, 0x8a, 0x08, 0x2c, 0x32, 0x77, 0x6a, 0x72, 0xff, 0x3d,
	0xa6, 0x13, 0x0c, 0xbe, 0x3e, 0x4b, 0xe9, 0x76, 0x35, 0x85, 0x93, 0x91, 0x9b, 0x25, 0x14, 0x10,
	0x08, 0x49, 0x39, 0xa9, 0x9a, 0x9c, 0x06, 0x1c, 0x4b, 0xf9, 0xae, 0x12, 0x94, 0xfa, 0x08, 0x55,
	0xaa, 0x05, 0x58, 0x10, 0x29, 0x80, 0x76, 0xe4, 0xac, 0x4b, 0x67, 0xdc, 0xdf, 0x87, 0x19, 0x6d,
	0x42, 0x66, 0x7c, 0x8c, 0xf7, 0x8d, 0x01, 0x29, 0x35, 0xba, 0xc7, 0x60, 0x4d, 0xe1, 0xb7, 0xd3,
	0xe7, 0xe3, 0xb0, 0x67, 0x3e, 0x38, 0x40, 0x67, 0x76, 0xd8, 0xa7, 0xd3, 0xd4, 0x72, 0xa4, 0x70,
	0xb6, 0x31, 0x51, 0xa0, 0x40, 0x4f, 0xaf, 0xab, 0x52, 0x8c, 0xf7, 0xf8, 0x74, 0x98, 0xaf, 0xbe,
	0x6e, 0x23, 0xd7, 0x47, 0xa1, 0x5d, 0x1b, 0x4e, 0xa2, 0x97, 0xd9, 0xc2, 0x26, 0x79, 0xb9, 0xf8,
	0xae, 0x5e, 0x04, 0x6d, 0xd5, 0xd0, 0xa7, 0x98, 0x6a, 0xce, 0xaa, 0x5f, 0xe4, 0xf9, 0xb8, 0xd2,
	0xbe, 0x1e, 0xcc, 0x55, 0xcb, 0x70, 0x0f, 0x6f, 0x81, 0x28, 0xcb, 0xf8, 0x8c, 0x5d, 0x7e, 0x55,
	0xd3, 0x27, 0xc9, 0xa9, 0x85, 0xa6, 0xc0, 0xf5, 0x79, 0xed, 0xc0, 0x7b, 0x1c, 0x36, 0xc3, 0xbd,
	0xa5, 0x8e, 0xa8, 0x77, 0x60, 0xe0, 0x39, 0xcd, 0x9a, 0x65, 0x60, 0x8b, 0x33, 0xfc, 0x2b, 0x49,
	0xa8, 0xca, 0x67, 0xba, 0x44, 0xaf, 0xf9, 0x29, 0x5d, 0x71, 0x30, 0x85, 0xe0, 0xe5, 0x16, 0xe0,
	0x25, 0x44, 0xc2, 0xab, 0x42, 0xf3, 0x48, 0x26, 0x01, 0x3f, 0x09, 0x59, 0xf5, 0x7f, 0xde, 0xce,
	0x49, 0x23, 0x38, 0xc6, 0x55, 0xd1, 0x47, 0xc6, 0x5b, 0xee, 0x9b, 0x6a, 0x9d, 0x0d, 0x72, 0x3c,
	0x36, 0x39, 0xf9, 0xdd, 0xf1, 0xd3, 0x84, 0x70, 0xe9, 0x05, 0x12, 0x10, 0x62, 0xcb, 0x6e, 0xbc,
	0x3f, 0xcb, 0x34, 0x73, 0xf6, 0x6f, 0xc4, 0x17, 0x0d, 0xe8, 0xeb, 0x25, 0x5c, 0xdf, 0xa0, 0x86,
	0x8c, 0xc3, 0xb9, 0x4a, 0xbb, 0x7e, 0x38, 0xc1, 0x17, 0x08, 0xd0, 0x93, 0x0f, 0x3e, 0xcf, 0x27,
	0x71, 0xa0, 0x72, 0xe7, 0xee, 0x7b, 0x41, 0x33, 0x4d, 0xfb, 0xaf, 0x5c, 0x55, 0xf7, 0xdc, 0xd9,
	0xf2, 0x14, 0x7d, 0xea, 0xe3, 0x08, 0xd6, 0xd3, 0xa0, 0xfa, 0x52, 0x17, 0x1b, 0x10, 0xce, 0x70,
	0xb6, 0xb9, 0xcf, 0xb4, 0x25, 0x9b, 0x42, 0x53, 0x67, 0x2b, 0x57, 0x7c, 0xff, 0x72, 0xa1, 0x83,
	0xcd, 0x08, 0xd3, 0x11, 0xae, 0x30, 0x9c, 0x0a, 0x01, 0x25, 0x73, 0x45, 0x7a, 0xfe, 0x78, 0xe9,
	0xf6, 0x3f, 0x5d, 0x0a, 0x35, 0x9f, 0x45, 0x48, 0x04, 0x48, 0xfe, 0x81, 0xc2, 0xc4, 0x82, 0x41,
	0xde, 0xa2, 0xb1, 0x67, 0x6a, 0x3b, 0x5b, 0x0c, 0x06, 0xb4, 0x6e, 0xe6, 0x0e, 0x15, 0xef, 0x12,
	0x3c, 0x7c, 0xd7, 0x49, 0xf3, 0x9c, 0x5b, 0x06, 0xf1, 0x2b, 0x45, 0xec, 0x99, 0x45, 0xaf, 0x10,
	0x17, 0x60, 0x66, 0x49, 0x85, 0x75, 0x02, 0x3d, 0xae, 0xe4, 0x15, 0xa8, 0xd7, 0xdf, 0xb7, 0x95,
	0xa3, 0x2d, 0xb3, 0x55, 0x19, 0x46, 0x3d, 0x62, 0x88, 0x08, 0x66, 0xf9, 0x4a, 0xb3, 0xa3, 0x3e,
	0x85, 0x79, 0x20, 0xaf, 0xed, 0xa7, 0x41, 0xa2, 0x8f, 0xa8, 0x84, 0x93, 0x46, 0x88, 0xb0, 0x1e,
	0x88, 0x58, 0x0b, 0x16, 0xc6, 0x28, 0x4b, 0x01, 0x7d, 0x8d, 0x54, 0x61, 0x1d, 0x57, 0x94, 0xfb,
	0x84, 0x6b, 0xea, 0xa4, 0x86, 0x98, 0x1b, 0x5e, 0xdb, 0x53, 0xcd, 0xf6, 0x0b, 0x44, 0xf0, 0xa9,
	0xb0, 0xcd, 0x1f, 0xda, 0x5e, 0xd0, 0xea, 0xb1, 0xe1, 0x70, 0xdf, 0x16, 0x44, 0xc2, 0xd0, 0x97,
	0xf9, 0xca, 0x88, 0x93, 0xf6, 0x4c, 0x12, 0xa3, 0x91, 0x2f, 0x16, 0x9f, 0x7b, 0xef, 0x2a, 0x7c,
	0x47, 0xf1, 0xbf, 0x16, 0xd6, 0x7b, 0xfc, 0x49, 0x91, 0xd9, 0xee, 0x84, 0xa8, 0xed, 0x84, 0xfb,
	0x2d, 0x84, 0x2d, 0x0c, 0x4e, 0xad, 0xee, 0x26, 0x81, 0xb2, 0x61, 0x27, 0x14, 0x3a, 0x9a, 0x32,
	0x2f, 0xf6, 0xac, 0xa7, 0xc6, 0xaa, 0x57, 0x37, 0x02, 0x23, 0x94, 0x26, 0xd3, 0xe5, 0x12, 0x84,
	0xdc, 0x53, 0x43, 0x76, 0x91, 0x79, 0xf6, 0x83, 0xef, 0x4a, 0x4c, 0xd8, 0x31, 0x76, 0x7d, 0xb4,
	0xe3, 0xb2, 0x78, 0x5c, 0x9d, 0xf4, 0xf7, 0x71, 0xf9, 0xd7, 0xdb, 0x64, 0xad, 0x8b, 0x36, 0x62,
	0x2c, 0xd5, 0x38, 0x32, 0x9e, 0x7b, 0xb3, 0xca, 0x83, 0xb3, 0x98, 0x78, 0x46, 0x9b, 0xf6, 0x69,
	0xa0, 0x57, 0xdb, 0x82, 0x8a, 0x3b, 0xaa, 0x69, 0x01, 0x1a, 0xf4, 0x1d, 0x80, 0x8f, 0xa8, 0x19,
	0x78, 0xe2, 0x56, 0x79, 0x78, 0x38, 0xb4, 0x09, 0x5c, 0x8d, 0x14, 0xf1, 0x35, 0x7a, 0x23, 0xa1,
	0xe1, 0x83, 0xaa, 0xf9, 0xbe, 0x5b, 0x81, 0x3a, 0xdc, 0x83, 0x47, 0xf9, 0xd1, 0xe4, 0x24, 0x84,
	0xfd, 0x51, 0xb8, 0x8a, 0xf5, 0xe3, 0x70, 0xee, 0xb4, 0xa6, 0x55, 0x57, 0xb5, 0xe3, 0xb9, 0x2e,
	0xfa, 0x26, 0x48, 0x01, 0xcd, 0x4a, 0x79, 0x70, 0x61, 0x76, 0xd6, 0xe9, 0xcd, 0x40, 0x63, 0x64,
	0x1f, 0xdd, 0xe4, 0x6e, 0x39, 0xb3, 0x3e, 0x3d, 0x28, 0xe4, 0xf6, 0x0b, 0x6c, 0x7a, 0xa9, 0x0d,
	0xcd, 0xd4, 0x5e, 0x33, 0xf7, 0x03, 0xde, 0x74, 0x51, 0xd3, 0xe0, 0x69, 0x58, 0x48, 0x5f, 0x80,
	0x8f, 0x73, 0x61, 0x16, 0xe7, 0x1c, 0x17, 0x34, 0x14, 0x7a, 0x93, 0xba, 0x3a, 0xbc, 0x21, 0x61,
	0xa9, 0x54, 0xe7, 0x89, 0x76, 0xf7, 0xb5, 0x86, 0x18, 0x76, 0x30, 0x26, 0x43, 0x50, 0xe8, 0x91,
	0x6b, 0xa8, 0xd9, 0x9a, 0x8f, 0xe1, 0x79, 0x9d, 0x9f, 0x13, 0xf7, 0x16, 0xf7, 0xe1, 0xeb, 0xd7,
	0xd5, 0x5e, 0xa7, 0x45, 0x4a, 0x7e, 0x6e, 0x3b, 0x62, 0xaa, 0x85, 0xa2, 0xfb, 0xa1, 0x2f, 0x47,
	0x9d, 0xcf, 0xf0, 0xcc, 0x91, 0xb9, 0x3c, 0xb4, 0x79, 0xe5, 0x68, 0x22, 0xaa, 0x1d, 0x2e, 0x5c,
	0x86, 0x3b, 0x2a, 0x28, 0x3e, 0x88, 0xd1, 0xc2, 0xc9, 0x32, 0x3b, 0x97, 0xa7, 0xd7, 0x48, 0xc4,
	0x65, 0xdd, 0x1b, 0xa2, 0xba, 0x20, 0xd4, 0x21, 0x38, 0x40, 0x0c, 0x18, 0x40, 0x77, 0x2e, 0x55,
	0xb5, 0x78, 0x65, 0xc9, 0x2e, 0x2d, 0x5a, 0x43, 0x41, 0xd5, 0x9e, 0x71, 0x68, 0x76, 0x07, 0x66,
	0xfc, 0x1c, 0x26, 0xdf, 0x18, 0xa7, 0xe4, 0x5a, 0x53, 0x9b, 0x50, 0x47, 0x76, 0xc5, 0xe1, 0xff,
	0x4b, 0x10, 0x29, 0x1f, 0x5c, 0x57, 0x58, 0xc1, 0xc3, 0xb1, 0xf7, 0xdd, 0x24, 0xd1, 0xaf, 0x13,
	0xb1, 0x13, 0xfb, 0x2a, 0x06, 0xcf, 0xc5, 0x47, 0x58, 0xa0, 0xbd, 0x0c, 0xf2, 0xbb, 0x3d, 0xcb,
	0x01, 0x91, 0xa3, 0xc9, 0x4e, 0xb6, 0x76, 0x35, 0x22, 0xec, 0x84, 0x7c, 0xe1, 0x0b, 0xb9, 0xc4,
	0xae, 0x1b, 0xf6, 0x84, 0xbf, 0x76, 0x40, 0x65, 0x6c, 0x1f, 0x2a, 0xbe, 0x01, 0x95, 0xbd, 0xaa,
	0x09, 0xf2, 0x86, 0x46, 0xb1, 0x52, 0x6b, 0x24, 0x47, 0x8f, 0x4b, 0x4d, 0x98, 0x95, 0x56, 0x42,
};


void func_97c_c(uint8_t *encstart, int length, uint8_t *scratch)
{
	int num_chunks = (length / KEY_LENGTH);
	int remainder  = length - (num_chunks * KEY_LENGTH);
	int chunk, i;

	memset(scratch, 0, KEY_LENGTH);

	if(num_chunks > 0) {
		for(chunk = 0; chunk < num_chunks; chunk++) {
			for(i = 0; i < KEY_LENGTH; i++) {
				scratch[i] ^= encstart[i + (chunk * KEY_LENGTH)];
			}
		}
	}

	for(i = 0; i < remainder; i++) {
		scratch[i] ^= encstart[(num_chunks * KEY_LENGTH) + i];
	}

	for(i = 0; i < KEY_LENGTH; i++) {
		scratch[i] = ~scratch[i];
	}
}

int func_abc_c(uint8_t *encstart, uint8_t *kworking, int length)
{
	uint8_t scratch[KEY_LENGTH];

	func_97c_c(encstart, length, scratch);
	return (int8_t)(memcmp(scratch, kworking, KEY_LENGTH));
}

int func_b1c_c(uint8_t *enc)
{
	int i, chunk;
	uint8_t scratch[32];

	// Select a decryption key between 0 and 31
	uint8_t key_idx = enc[998] & 0x1f;

	// Load the 32-byte key
	uint8_t *key = &firmware_directory_key[key_idx * 32];

	// Calculate the first 20 bytes of a key...  # b4c
	for (i = 0; i < 20; i++) {
		uint8_t xored = enc[1000 + i] ^ key[i];

		enc[1000 + i] = xored;
		scratch[i] = xored;
	}

	// And then copy the first 16 bytes of that calculated key into the rest of the key.  # b80
	for (i = 20; i < 32; i++) {
		scratch[i] = scratch[i - 20];
	}

	// Use the calculated key to descramble the rest of the block.  #bac
	for (chunk = 0; chunk < 31; chunk++) {
		for (i = 0; i < 32; i++) {
			enc[(chunk * 32) + i] ^= (scratch[i] ^ firmware_directory_key[(chunk * 32) + i]);
		}
	}
	
	return func_abc_c(enc - 1, enc + 1000, 1001);
}

struct inituse_detail {
	uint8_t loc0[32];
	uint8_t loc32[16];
	uint8_t loc48[512];
	uint8_t loc560[16384];
	uint8_t loc16944[512];
	uint8_t loc17456[2432];
};

// NB this isn't used yet
struct glbuffer_detail {
	uint8_t loc0[256];
	uint32_t unused_1;
	uint16_t rounds_to_perform;
	uint16_t unused_2;
	uint8_t key[32];
	uint32_t unused_3;
};

int func_fw_decrypt_init_c(struct decrypt_struct *decrypt)
{
	int ret;

	/* Ensure we got what we expect */
	if(decrypt->InOutLen != DECRYPT_INOUT_LENGTH)
		return 48;

	if(decrypt->InOutLen - 2048 != (16 * 1024))
		return 48; // TODO clearly unnecessary

	if(decrypt->initusebufferlen != DECRYPT_INIT_LENGTH)
		return 48;

	struct inituse_detail *inituse = (struct inituse_detail *)decrypt->initusebuffer;
	assert(decrypt->initusebufferlen == sizeof(struct inituse_detail));

	/* Clear buffer */
	memset(decrypt->initusebuffer, 0, DECRYPT_INIT_LENGTH);

	/* 2358 */
	int8_t sp_40, sp_41;
	if((ret = func_1db4(decrypt->FileLength,
					decrypt->pInOutBuffer,
					&sp_40,
					&sp_41,
					decrypt->initusebuffer + 32,
					decrypt->initusebuffer,
					decrypt->initusebuffer + 48,
					decrypt->pGLBuffer,
					decrypt->initusebuffer + 17456)) != 0)
		return ret;

	// The firmware check routine above returns two sector counts minus 1
	// We end up copying the sectors as follows:
	// <start of file>
	//  * skip 512 bytes
	//  * copy sp_40 sectors plus 1
	//  * skip 1024 bytes
	//  * copy sp_41 sectors plus 1
	//  * skip 512 bytes
	//  * copy 30 - sp_40 - sp_41 sectors (for a total of 16k copied)
	// The sectors are concatenated into initUseBuffer and decrypted.

	int32_t sp_40_bytes = (((int32_t)sp_40) * 512) + 512;
	int32_t sp_41_bytes = (((int32_t)sp_41) * 512) + 512;

	/* 23a0 moved up */

	/* 23b4 */
	memset(inituse->loc560, 0, (16 * 1024));

	uint8_t *sectors_src = decrypt->pInOutBuffer + 512; /* 23c8 */
	uint8_t *sectors_dst = inituse->loc560;

	memcpy(sectors_dst, sectors_src, sp_40_bytes);

	sectors_src += sp_40_bytes + 1024; /* 23ec */
	sectors_dst += sp_40_bytes;
	memcpy(sectors_dst, sectors_src, sp_41_bytes);

	sectors_src += sp_41_bytes + 512; /* 2418 */
	sectors_dst += sp_41_bytes;
	memcpy(sectors_dst, sectors_src, (32 * 512) - sp_40_bytes - sp_41_bytes);

	/* This determines the number of rounds of crypto to perform. For every
	 * 32MB that the firmware is smaller than 512MB, do another round, but
	 * always do at least one. This seems like it was designed to keep
	 * decryption time constant, but it's odd (it's a one-off firmware upgrade
	 * -- not exactly speed critical, and decryption time is a small fraction
	 *  of total upgrade time anyway) and unsound (larger files get fewer
	 *  rounds of encryption than smaller files).
	*/
	int16_t rounds_to_perform = 16 - (decrypt->FileLength >> 0x19);
	if(rounds_to_perform <= 0)
		rounds_to_perform = 1;

	// Decrypt the concatenated block.
	uint8_t *current_sector = inituse->loc560; // 245c
	int length = 16 * 1024;

	while(length >= 512) {
		func_268c(current_sector, (uint8_t *)inituse, rounds_to_perform); // 246c
		length -= 512;
		current_sector += 512;
	}

	// decrypt partial sector at the end.
	if(length != 0) { // 2510
		// TODO: This is clearly dead code, so what's it for?
		memcpy(inituse->loc16944, inituse->loc560, length);
		func_268c(inituse->loc16944, (uint8_t *)inituse, rounds_to_perform);
		memcpy(inituse->loc560, inituse->loc16944, length);
	}

	// The -2048 stuff here and below is because we skipped (512 + 1024 + 512)
	// bytes of data when copying in with the memcpy calls above.

	// Copy the decrypted data to the output buffer: it's always going to be 16k
	memcpy(decrypt->pInOutBuffer, inituse->loc560, decrypt->InOutLen-2048); // 2498

	// Store the number of rounds for later
	memcpy(&(decrypt->pGLBuffer[260]), &rounds_to_perform, 2);

	// Store encrypt key or encryption initial state?
	memcpy(&(decrypt->pGLBuffer[264]), inituse, 32);

	// Return the number of bytes decrypted.
	decrypt->InOutLen -= 2048;
	
	return 0; // success
}

